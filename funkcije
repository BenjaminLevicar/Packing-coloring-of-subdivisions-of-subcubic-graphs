import random
import matplotlib.pyplot as plt

def generate_subcubic_graphs(n):
    """ Generates all subcubic graphs with n vertices"""
    return [G for G in graphs.nauty_geng(f"{n} -c -D3")]


def is_subcubic(G):
    """Checks if the graph G is subcubic"""
    max_degree = max(G.degree_iterator())
    return max_degree < 4

def subdivizija(G):
    """Makes a subdivision of a given graph"""
    H = G.copy()
    H.subdivide_edges(G.edges(), 1)
    return H


def narisi_grafe(n):
    """ Draws all subcubic graphs with n vestices"""
    subcubic_graphs = generate_subcubic_graphs(n)
    # subcubic_graphs = subdivisions(subcubic_graphs) # Če hočemo narisati subdivizije grafov
    for i, graph in enumerate(subcubic_graphs):
        print(f"Graph {i + 1}:")
        cleaned_edges = [(u, v) for u, v, *_ in graph.edges()]
        print("Edges:", cleaned_edges)
        graph.show(title=f"Graph {i + 1}", vertex_size=300, vertex_color="gold")




def random_subcubic_graph(n):
    """Generates a random subcubic graph on n vertices"""
    # Initialize a graph with n vertices and no edges
    G = Graph(n)

    # Make list for stopping time
    Choice = [0,1,2,3,4]
    
    # Keep track of the degree of each vertex
    degrees = {v: 0 for v in range(n)}
    
    # Randomly add edges while ensuring max degree is at most 3
    while True:
        a = random.choice(rand) 
        if a == 0 and G.is_connected() == True: # If the graph is connected than we have 1/5 chance to stop sooner to give generated graphs some diversety
            return G
        # Get all pairs of vertices with degree < 3
        possible_edges = [(u, v) for u in range(n) for v in range(u + 1, n)
                          if degrees[u] < 3 and degrees[v] < 3 and not G.has_edge(u, v)]
        if not possible_edges:
            break
        
        # Choose a random edge to add
        u, v = random.choice(possible_edges)
        G.add_edge(u, v)
        degrees[u] += 1
        degrees[v] += 1
    
    return G



def modify_graph(G, n):
    """Adds or removes an edge so that the graph stays connected and subcubic"""
    action = random.choice(['add', 'remove']) # Makes a random choice to either add or remove an edge
    
    added_edges = set(G.edges())
    
    if action == 'add':
        possible_edges = [(u, v) for u in range(n) for v in range(u + 1, n) if (u, v) not in added_edges and not G.has_edge(u, v)] # Makes a list of all empty edges
        
        if possible_edges:
            u, v = random.choice(possible_edges) # Ramdomly picks an empty edge to add
            G.add_edge(u, v)
            added_edges.add((u, v)) 
    
    elif action == 'remove':
        (u, v, *_) = random.choice(list(G.edges())) # picks an edge to remove
        G.delete_edge(u, v)
        added_edges.discard((u, v))

    # Checks if the graph is connected and subcubic. If not, it changes it until it is
    while not G.is_connected() or not is_subcubic(G):
        if not G.is_connected():
            components = list(G.connected_components(sort=True))
            u, v = random.choice(list(components[0])), random.choice(list(components[1])) # Adds an edge to connect 2 components if graph is not connected 
            G.add_edge(u, v)
            added_edges.add((u, v)) 
        elif not is_subcubic(G):
            (u, v, *_) = random.choice(list(G.edges())) # Removes a random edge
            G.delete_edge(u, v)
            added_edges.discard((u, v))  
    
    return G



n = 5
G = random_subcubic_graph(n)
num_steps = 6
target_packing_coloring = 6
previous_packing_coloring = 0
previous_graph = G 
step = 0
invalid_steps = 0 
packing_coloring = 0
slovar_slovarjev_barv = []
i=1

while step < num_steps and invalid_steps < 10000: 
    print(i)
    new_G = modify_graph(G.copy(), n)  
    
    #if previous_graph.is_isomorphic(new_G):
     #   invalid_steps += 1 
      #  continue 
        
    new_Gi = subdivizija(new_G)
    (f, packing_coloring, slovar) = poisci_pakirno_stevilo(new_Gi, 7, 3)
    seznam_slovarjev_barv.append(slovar)
    i+=1
    
    #if packing_coloring < previous_packing_coloring:
     #   invalid_steps += 1
      #  continue
    
    previous_packing_coloring = packing_coloring
    step += 1
    invalid_steps = 0
    
    print(f"Step {step}: Packing coloring number of subdivision: {packing_coloring}")
    
    #new_G.plot(
    #layout="spring",                # Use the spring layout
    #vertex_size=500,                # Set the vertex size
    #vertex_color="lightblue",       # Set the vertex color
    #vertex_labels=True,             # Show vertex labels
    #vertex_label_color="black",     # Label color
    #vertex_label_size=12,           # Label size
   # #edge_color="gray",              # Edge color
    #edge_thickness=1.5,             # Edge thickness
    #title=f"Graph at step {step}",  # Add title
    #figsize=[6, 6]      # Set the figure size
    #).show()
    new_G.show()

    #plt.figure(figsize=(6, 6))
    #pos = new_G.spring_layout()  
    #new_G.plot(pos, with_labels=True, node_color='lightblue', node_size=500, font_size=12, font_weight='bold', edge_color='gray')
    #plt.title(f"Graph at step {step}")
    #plt.show()
    
    if packing_coloring == target_packing_coloring:
        print(f"Target reached at step {step}")
        break

    G = new_G
    previous_graph = new_G  

new_G.plot()
print(seznam_slovarjev_barv)
if invalid_steps >= 10000:
    print("No new valid graphs after 10000 steps, stopping.")



n = 5
for graph in generate_subcubic_graphs(n):
    G = graph  
    V = G.vertices()
#E = G.edges(labels=False)
    n = len(G.vertices())

    b = 10  # Maximum number of colors to test

# Initialize the ILP problem
    p = MixedIntegerLinearProgram(maximization=False)
    X = p.new_variable(binary=True)  # X_h: Binary variables for color usage
    Y = p.new_variable(binary=True)  # Y_i^h: Binary variables for vertex-color assignment
    Z = p.new_variable(binary=True)  # Z_i,j^h Binary variables for vertex-vertex-color assignment
    C = G.distance_matrix()

# Objective Function: Minimize the number of colors used
    p.set_objective(p.sum(X[k] for k in range(1, b)))

# Constraint 1: If the color k is not used, the color k+1 will also not be used
    for k in range(1, b):
        p.add_constraint(X[k] >= X[k+1])

# Constraint 2: Ensure consistency between Z and Y variables
    for i in V:
        for j in V:
            if i != j:
                for k in range (1, b+1):
                    p.add_constraint(Z[i, j, k] <= Y[i, k])
                    p.add_constraint(Z[i, j, k] <= Y[j, k])
                    p.add_constraint(Z[i, j, k] >= (Y[i, k] + Y[j, k] - 1))


# Constraint 3: If vertex i is assigned color k, color k must be used
    for k in range(1, b+1):
        for i in V:
            p.add_constraint(Y[i, k] <= X[k])
        
# Constraint 4: Vertices of the same color must be at least i + 1 edges apart
    for i in V:
        for j in V:
            for k in range (1, b+1):
                p.add_constraint(C[i][j] >= ((k + 1)*Z[i, j, k]))

# Constraint 5: Every vertex must be colored
    for i in V:
        p.add_constraint(p.sum(Y[i, k] for k in range(1, b+1)) == 1)  # Use sum() instead of p.sum()
            
# Solve the ILP
    solution = p.solve()

# Display results
    graph.show(title=f"Graph {i + 1}", vertex_size=300, vertex_color="gold")
    print("Minimum number of colors used:", sum(p.get_values(X[k]) for k in range(1, b+1)))
    for i in V:
        for k in range(1, b+1):
            if p.get_values(Y[i, k]) > 0.5:  # Ensure binary condition
                print(f"Vertex {i} is assigned color {k}")
